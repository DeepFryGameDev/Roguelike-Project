using System.Collections;
using System.Collections.Generic;
using UnityEngine;

// Purpose: Handles projectile particle collision and movement
// Directions: Attach to any attack projectile prefab in /Particles folder
// Other notes:

public class ParticleCollision : MonoBehaviour
{
    // Attached to every particle to be checked for collision for an attack made by an enemy or player

    [Tooltip("Is set to the attack when the particle is generated by the unit's AttackManager")]
    public AttackScriptableObject attack;

    [Tooltip("Attacker's type - player or enemy")]
    public EnumHandler.UnitTypes sourceUnitType;

    bool selfDestructing; // set to true when the particle is created, used for StartSelfDestruct()

    int playerLayerMask = 1 << 11;
    int enemyLayerMask = 1 << 10;

    float collisionRadius = 5f;

    List<GameObject> collidedTargets = new List<GameObject>(); // Is used to ensure the same target is not applied twice

    void Update()
    {
        if (attack.attackProjectionType == EnumHandler.AttackProjectionTypes.PROJECTILE)
        {
            transform.position += transform.forward * Time.deltaTime * attack.projectionSpeed;
        }

        if (attack != null && !selfDestructing)
        {
            //Debug.Log("Self destructing " + gameObject.name + " after " + attack.projectionTime + " seconds");
            StartCoroutine(StartSelfDestruct());
        }
    }

    /// <summary>
    /// Triggers on callback from any ParticleSystem > Trigger
    /// This method specifically checks for sourceUnitType, and then checks for potential targets, and applies damage to any targets hit by the particle
    /// </summary>
    void OnParticleTrigger()
    {
        int maxColliders = 20;
        Collider[] hitColliders = new Collider[maxColliders];

        if (sourceUnitType == EnumHandler.UnitTypes.PLAYER)
        {
            int numOfCollisions = Physics.OverlapSphereNonAlloc(transform.position, collisionRadius, hitColliders, enemyLayerMask);

            for (int i = 0; i < numOfCollisions; i++)
            {
                if (!collidedTargets.Contains(hitColliders[i].gameObject))
                {
                    collidedTargets.Add(hitColliders[i].gameObject);

                    Debug.Log("Player attacks " + hitColliders[i].GetComponent<BaseEnemy>().enemySO.name + "!");
                    Debug.Log("Dealing " + attack.damage + " damage to " + hitColliders[i].gameObject.name);

                    hitColliders[i].GetComponent<BaseEnemy>().TakeDamage(attack.damage);

                    if (attack.attackProjectionType == EnumHandler.AttackProjectionTypes.PROJECTILE)
                    {
                        Destroy(gameObject);
                    }
                }                
            }
        }

        if (sourceUnitType == EnumHandler.UnitTypes.ENEMY)
        {
            int numOfCollisions = Physics.OverlapSphereNonAlloc(transform.position, 5f, hitColliders, playerLayerMask);

            for (int i = 0; i < numOfCollisions; i++)
            {
                if (!collidedTargets.Contains(hitColliders[i].transform.parent.gameObject))
                {
                    collidedTargets.Add(hitColliders[i].transform.parent.gameObject);

                    Debug.Log("Enemy attacks the player!");
                    Debug.Log("Dealing " + attack.damage + " damage to " + hitColliders[i].transform.parent.gameObject.name);

                    hitColliders[i].transform.parent.GetComponent<BasePlayer>().TakeDamage(attack.damage);

                    if (attack.attackProjectionType == EnumHandler.AttackProjectionTypes.PROJECTILE)
                    {
                        Destroy(gameObject);
                    }
                }
            }
        }
    }

    /// <summary>
    /// Called immediately when the particle gameObject is created in the world.  This will ensure the particle is only in the world for it's projectionTime
    /// </summary>
    IEnumerator StartSelfDestruct()
    {
        selfDestructing = true;
        yield return new WaitForSeconds(attack.projectionTime);
        Destroy(gameObject);
    }
}
